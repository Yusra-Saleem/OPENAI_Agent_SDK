
# Guardrails in OpenAI Agent SDK

This document provides a detailed and beginner-friendly explanation of Guardrails in the OpenAI Agent SDK. It covers the core concepts, different types, and practical implementation with in-depth code examples.

-----

## 1. What are Guardrails?

Guardrails act as a **safety and control mechanism** for your agents. Think of them as a protective barrier. Just as physical guardrails on a road prevent a car from going off-track, these digital guardrails ensure your agent's behavior remains within defined boundaries.

The primary purpose of guardrails is to:

  * **Prevent Misuse:** They stop the agent from responding to malicious, harmful, or off-topic requests.
  * **Save Resources:** By filtering out unnecessary queries early, they prevent the use of large, expensive, and slow models, which saves both time and money.
  * **Maintain Relevance:** They ensure the agent stays focused on its intended purpose and does not engage in irrelevant conversations.

Guardrails run **in parallel** to or immediately before/after your agent's main execution. They are typically implemented using a smaller, faster model that performs a quick check. If the check fails, the guardrail triggers a "tripwire" to halt the agent's execution.

-----

## 2. Types of Guardrails

There are two main types of guardrails, each serving a specific purpose in the agent's workflow.

### 2.1. Input Guardrails

**Input Guardrails** are checks that run on the **initial user input** before it reaches the main agent. Their goal is to validate the user's request and stop the process if the input is inappropriate or outside the agent's scope.

**How They Work (3 Steps):**

1.  **Receive Input:** The guardrail receives the exact same input that the user provides to the agent.
2.  **Run Guardrail Function:** A dedicated guardrail function analyzes the input and produces a `GuardrailFunctionOutput`. This output contains information about the check and a crucial boolean value, `tripwire_triggered`.
3.  **Check Tripwire:** The system checks if the `tripwire_triggered` value is `True`. If it is, an `InputGuardrailTripwireTriggered` exception is raised, immediately stopping the agent's execution.

### 2.2. Output Guardrails

**Output Guardrails** are checks that run on the **final output** produced by the agent, right before it is sent to the user. Their purpose is to validate the agent's response for safety, accuracy, and adherence to specific rules.

**How They Work (3 Steps):**

1.  **Receive Output:** The guardrail receives the final output generated by the agent.
2.  **Run Guardrail Function:** The guardrail function analyzes the agent's output and returns a `GuardrailFunctionOutput` with the `tripwire_triggered` value.
3.  **Check Tripwire:** If the `tripwire_triggered` value is `True`, an `OutputGuardrailTripwireTriggered` exception is raised. This halts the process, preventing the problematic response from being sent to the user.

-----

## 3. Understanding Tripwires

A **Tripwire** is the core mechanism that signals a guardrail failure. It is the "emergency brake" for the agent's execution.

When a guardrail function returns `tripwire_triggered=True`, the system does not wait for the entire process to complete. It **immediately raises an exception**. This design is used for several reasons:

  * **Immediate Halt:** It ensures that execution is stopped as soon as a problem is detected, preventing further processing of a harmful or irrelevant task.
  * **Clear Error Signaling:** The specific exception raised provides a clear, programmatic way to handle the error in your code using a `try...except` block.
  * **Efficiency:** By stopping early, it conserves valuable computing resources and reduces operational costs.

-----

## 4. Practical Implementation with Code Examples

Implementing a guardrail involves creating a special function that performs a check and returns a `GuardrailFunctionOutput` object. This function is then associated with your agent.

### 4.1. Input Guardrail Example: Blocking Math Homework

This example shows how to use an input guardrail to block a "Customer Support Agent" from answering math homework questions.

```python
from pydantic import BaseModel
from agents import (
    Agent,
    GuardrailFunctionOutput,
    InputGuardrailTripwireTriggered,
    RunContextWrapper,
    Runner,
    TResponseInputItem,
    input_guardrail,
)

class MathHomeworkOutput(BaseModel):
    is_math_homework: bool
    reasoning: str

guardrail_agent = Agent( 
    name="Guardrail check",
    instructions="Check if the user is asking you to do their math homework.",
    output_type=MathHomeworkOutput,
)

@input_guardrail
async def math_guardrail( 
    ctx: RunContextWrapper[None], agent: Agent, input: str | list[TResponseInputItem]
) -> GuardrailFunctionOutput:
    result = await Runner.run(guardrail_agent, input, context=ctx.context)
    return GuardrailFunctionOutput(
        output_info=result.final_output, 
        tripwire_triggered=result.final_output.is_math_homework,
    )

agent = Agent(  
    name="Customer support agent",
    instructions="You are a customer support agent. You help customers with their questions.",
    input_guardrails=[math_guardrail],
)

async def main():
    try:
        await Runner.run(agent, "Hello, can you help me solve for x: 2x + 3 = 11?")
        print("Guardrail didn't trip - this is unexpected")
    except InputGuardrailTripwireTriggered:
        print("Math homework guardrail tripped")
    
    try:
        await Runner.run(agent, "Hello, can you help me with my order?")
        print("Guardrail didn't trip as expected.")
    except InputGuardrailTripwireTriggered:
        print("Unexpected: Math homework guardrail tripped on a valid request.")
```

### 4.2. Output Guardrail Example: Blocking Math in Output

This example demonstrates how an **Output Guardrail** can prevent the main agent from including any mathematical content in its final response.

```python
from pydantic import BaseModel
from agents import (
    Agent,
    GuardrailFunctionOutput,
    OutputGuardrailTripwireTriggered,
    Runner,
    output_guardrail,
    RunContextWrapper,
)

class MessageOutput(BaseModel): 
    response: str

class MathOutput(BaseModel): 
    reasoning: str
    is_math: bool

guardrail_agent = Agent(
    name="Guardrail check",
    instructions="Check if the output includes any math.",
    output_type=MathOutput,
)

@output_guardrail
async def math_guardrail(  
    ctx: RunContextWrapper, agent: Agent, output: MessageOutput
) -> GuardrailFunctionOutput:
    result = await Runner.run(guardrail_agent, output.response, context=ctx.context)
    return GuardrailFunctionOutput(
        output_info=result.final_output,
        tripwire_triggered=result.final_output.is_math,
    )

agent = Agent( 
    name="Customer support agent",
    instructions="You are a customer support agent. You help customers with their questions.",
    output_guardrails=[math_guardrail],
    output_type=MessageOutput,
)

async def main():
    try:
        await Runner.run(agent, "Hello, can you tell me the result of 2x + 3 = 11?")
        print("Guardrail didn't trip - this is unexpected")
    except OutputGuardrailTripwireTriggered:
        print("Math output guardrail tripped")
```
